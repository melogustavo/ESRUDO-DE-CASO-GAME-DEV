<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>StarRunner 2D — Single File</title>
  <style>
    html, body { margin:0; padding:0; background:#0e0e13; height:100%; }
    #game { width:100%; height:100%; touch-action:none; }
    .hud {
      position: fixed; top: 8px; left: 8px; right:8px; display:flex; justify-content:space-between; color:#fff; font-family: system-ui, Arial;
      z-index: 2; text-shadow: 0 2px 4px rgba(0,0,0,.6);
    }
    .btn {
      position: fixed; bottom: 18px; width: 72px; height: 72px; border-radius: 50%; background: rgba(255,255,255,.12);
      backdrop-filter: blur(6px); display:flex; align-items:center; justify-content:center; color:#fff; font-weight:700; z-index: 2;
      user-select:none; -webkit-user-select:none;
    }
    #btnLeft  { left: 18px; }
    #btnRight { left: 108px; }
    #btnJump  { right: 18px; width:86px; height:86px; }
  </style>
</head>
<body>
  <div class="hud"><div id="score">Score: 0</div><div id="lives">Vidas: 3</div></div>
  <div id="game"></div>
  <div id="btnLeft" class="btn">◄</div>
  <div id="btnRight" class="btn">►</div>
  <div id="btnJump" class="btn">⤒</div>

  <!-- Phaser CDN -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.js"></script>

  <script>
  // StarRunner 2D (Single File) — Phaser 3
  const hudScore = document.getElementById('score');
  const hudLives = document.getElementById('lives');

  const mobileControls = (()=>{
    const left = document.getElementById('btnLeft');
    const right = document.getElementById('btnRight');
    const jump = document.getElementById('btnJump');
    let state = { left:false, right:false, jump:false };
    const press = (btn, key)=>{
      btn.addEventListener('pointerdown', e=>{ e.preventDefault(); state[key]=true; });
      btn.addEventListener('pointerup', e=>{ e.preventDefault(); state[key]=false; });
      btn.addEventListener('pointerleave', e=>{ state[key]=false; });
      btn.addEventListener('touchcancel', e=>{ state[key]=false; });
    };
    press(left, 'left'); press(right, 'right'); press(jump, 'jump');
    return state;
  })();

  const config = {
    type: Phaser.AUTO,
    parent: 'game',
    width: 800, height: 450, pixelArt: true, backgroundColor: '#1a1c2c',
    physics: { default: 'arcade', arcade: { gravity: { y: 1200 }, debug: false } },
    scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
    scene: []
  };

  class HUD {
    static update(score, lives){
      hudScore.textContent = `Score: ${score}`;
      hudLives.textContent = `Vidas: ${lives}`;
    }
  }

  class LevelScene extends Phaser.Scene {
    constructor(key, nextKey, difficulty){
      super(key); this.nextKey = nextKey; this.diff = difficulty;
      this.lives = 3; this.score = 0; this.coyoteTime = 120; this.jumpBuffer = 120;
    }
    preload(){}
    create(){
      const w=50, h=14;
      this.makeLevel(w,h);
      this.cursors = this.input.keyboard.createCursorKeys();
      this.keyShift = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SHIFT);
      this.add.text(8,8,this.scene.key,{fontFamily:'monospace',fontSize:'12px',color:'#ffffff'}).setScrollFactor(0).setAlpha(.5);
      this.respawnPoint = this.player.getCenter();
      HUD.update(this.score, this.lives);
      this.lastGrounded = 0; this.lastJumpPress = -9999;
    }
    makeLevel(w,h){
      const mkTex = (name, color)=>{
        const g = this.add.graphics();
        g.fillStyle(color,1).fillRect(0,0,32,32);
        g.lineStyle(2,0x000000,.35).strokeRect(1,1,30,30);
        g.generateTexture(name,32,32); g.destroy();
      };
      mkTex('tile', 0x3a445d); mkTex('ladder',0x7ec8e3); mkTex('coin',0xf6d32d);
      mkTex('enemy',0xe15b64); mkTex('goal',0x67d17a); mkTex('player',0xf2a65a);
      mkTex('spike',0x9141ac);

      this.platforms = this.physics.add.staticGroup();
      const groundY = 400;
      for(let x=0;x<25;x++) this.platforms.create(16+32*x, groundY, 'tile').refreshBody();

      const rand = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
      const platCount = this.diff===1?6:this.diff===2?10:14;
      for(let i=0;i<platCount;i++){
        const px = rand(3,22)*32;
        const py = rand(6,11)*32;
        this.platforms.create(px, py, 'tile').refreshBody();
      }

      this.ladders = this.physics.add.staticGroup();
      for(let i=0;i<3+this.diff;i++){
        const lx = rand(4,22)*32, count = rand(2,5);
        for(let j=0;j<count;j++) this.ladders.create(lx, 368-32*j, 'ladder').setAlpha(.7).refreshBody();
      }

      this.hazards = this.physics.add.staticGroup();
      for(let i=0;i<4+this.diff;i++){
        const hx = rand(2,23)*32;
        this.hazards.create(hx, groundY-16, 'spike').refreshBody();
      }

      this.coins = this.physics.add.group();
      for(let i=0;i<10+this.diff*5;i++){
        const cx = rand(2,24)*32, cy = rand(3,10)*32;
        const c = this.coins.create(cx, cy, 'coin');
        c.body.allowGravity=false;
      }

      this.enemies = this.physics.add.group();
      for(let i=0;i<this.diff;i++){
        const ex = rand(4,22)*32, ey = rand(6,11)*32;
        const e = this.enemies.create(ex, ey, 'enemy');
        e.body.setCollideWorldBounds(true);
        e.setBounce(1,0); e.setVelocityX( (Math.random()<.5?-1:1) * (100+this.diff*30) );
      }

      this.goal = this.physics.add.staticImage(760, 360, 'goal');

      this.player = this.physics.add.sprite(64, 320, 'player');
      this.player.setBounce(0).setCollideWorldBounds(true);

      this.physics.add.collider(this.player, this.platforms);
      this.physics.add.collider(this.enemies, this.platforms);
      this.physics.add.collider(this.coins, this.platforms);

      this.physics.add.overlap(this.player, this.coins, (_p,c)=>{ c.destroy(); this.score+=10; HUD.update(this.score,this.lives); }, null, this);
      this.physics.add.overlap(this.player, this.goal, ()=> this.win(), null, this);
      this.physics.add.overlap(this.player, this.hazards, ()=> this.hurt(), null, this);
      this.physics.add.overlap(this.player, this.enemies, ()=> this.hurt(), null, this);

      this.cameras.main.setBounds(0,0,800,450);
      this.physics.world.setBounds(0,0,800,450);
      this.cameras.main.startFollow(this.player, true, 0.1, 0.1);
    }
    update(){
      const body = this.player.body;
      const onGround = body.blocked.down;
      if(onGround) this.lastGrounded = this.time.now;

      const left  = this.cursors.left.isDown || mobileControls.left;
      const right = this.cursors.right.isDown || mobileControls.right;
      const run   = this.keyShift.isDown;
      const speed = run ? 260 : 180;
      let vx = 0;
      if (left) vx = -speed;
      else if (right) vx = speed;
      body.setVelocityX(vx);

      const ladderOverlap = this.physics.overlapRect(this.player.x-8, this.player.y-16, 16, 32)
        .some(b=> b.gameObject && b.gameObject.texture && b.gameObject.texture.key==='ladder');
      if (ladderOverlap){
        body.setAllowGravity(false);
        const up = this.cursors.up.isDown || mobileControls.jump;
        const down = this.cursors.down.isDown;
        if(up) body.setVelocityY(-160);
        else if(down) body.setVelocityY(160);
        else body.setVelocityY(0);
      } else {
        body.setAllowGravity(true);
      }

      if (Phaser.Input.Keyboard.JustDown(this.cursors.up) || mobileControls.jump){
        this.lastJumpPress = this.time.now;
      }
      const canJump = (this.time.now - this.lastJumpPress <= this.jumpBuffer) && (this.time.now - this.lastGrounded <= this.coyoteTime);
      if (canJump){
        body.setVelocityY(-420);
        this.lastJumpPress = -9999;
        mobileControls.jump = false;
      }
    }
    hurt(){
      this.lives--;
      HUD.update(this.score, this.lives);
      if(this.lives<=0){ this.scene.start('GameOver'); }
      else { this.player.setPosition(this.respawnPoint.x, this.respawnPoint.y); }
    }
    win(){
      if(this.nextKey){ this.scene.start(this.nextKey); }
      else { this.scene.start('Victory', { score: this.score }); }
    }
  }

  class Level1 extends LevelScene { constructor(){ super('Level1','Level2',1); } }
  class Level2 extends LevelScene { constructor(){ super('Level2','Level3',2); } }
  class Level3 extends LevelScene { constructor(){ super('Level3',null,3); } }

  class GameOver extends Phaser.Scene {
    create(){
      this.add.text(400,200,'GAME OVER',{fontFamily:'monospace',fontSize:'32px',color:'#fff'}).setOrigin(.5);
      const b = this.add.text(400,280,'Tentar novamente',{fontFamily:'monospace',fontSize:'20px',backgroundColor:'#333',padding:{x:12,y:8},color:'#fff'}).setOrigin(.5).setInteractive();
      b.on('pointerup',()=> this.scene.start('Level1'));
    }
  }
  class Victory extends Phaser.Scene {
    init(data){ this.score = data?.score || 0; }
    create(){
      this.add.text(400,200,'VITÓRIA!',{fontFamily:'monospace',fontSize:'32px',color:'#fff'}).setOrigin(.5);
      this.add.text(400,240,`Score: ${this.score}`,{fontFamily:'monospace',fontSize:'20px',color:'#fff'}).setOrigin(.5);
      const b = this.add.text(400,300,'Menu / Recomeçar',{fontFamily:'monospace',fontSize:'20px',backgroundColor:'#333',padding:{x:12,y:8},color:'#fff'}).setOrigin(.5).setInteractive();
      b.on('pointerup',()=> this.scene.start('Level1'));
    }
  }

  config.scene = [Level1, Level2, Level3, GameOver, Victory];
  new Phaser.Game(config);
  </script>
</body>
</html>
